# AutoSlice â€” Project Context & Architecture Guide
**Repository:** [https://github.com/Angki/audio_slicer](https://github.com/Angki/audio_slicer)
**Author:** Angki
**Description:** A desktop application built with Electron for automatically slicing audio files based on silence detection, manually adding/removing markers, editing track metadata, matching with Discogs, and exporting to WAV/FLAC/MP3.

This file serves as a **hyperdetailed context guide** for AI assistants/agents to quickly understand the project's state, data flow, architecture, and UI/UX conventions without needing to read every file from scratch.

---

## 1. Project Architecture
The application is built using standard Electron architecture (Main Process + Renderer Process). No frontend frameworks (React/Vue) are used; the UI is built with vanilla HTML/CSS/JS for maximum performance and direct DOM manipulation.

### Backend (Node.js / Electron Main)
- **`src/main/index.js`**: Application entry point. Handles window creation, native dialogs, and IPC (Inter-Process Communication) routing.
- **`src/main/preload.js`**: Exposes safe, typed API methods to the frontend under `window.api`.
- **`src/main/services/AudioService.js`**: Core audio engine. Uses `fluent-ffmpeg` to decode audio, extract waveform peaks, compute RMS (Root Mean Square) volume, detect noise floors, and calculate silence gaps.
- **`src/main/services/ExportService.js`**: Handles splitting the audio based on markers. Uses complex FFmpeg filter graphs (`aselect`) to skip "Excluded" regions, applies ID3 tags (using `node-id3`), applies FLAC/WAV tags, and converts formats.
- **`src/main/services/DiscogsService.js`**: REST client for the Discogs API (Release Search, Tracklist parsing).
- **`src/main/utils/ffmpeg.js`**: Shared utility to resolve `ffmpeg-static` and `ffprobe-static` paths correctly, especially handling path modifications when the app is packaged into an `.asar` archive.

### Frontend (Vanilla JS / Renderer)
- **`src/renderer/index.html`**: The single HTML view. Structured logically: Toolbar -> Top Controls -> Waveform -> Bottom Controls -> Drag/Drop Zone. Includes a toast notification container.
- **`src/renderer/styles/main.css`**: Vanilla CSS. Uses CSS variables for theming. Uses modern patterns (Flexbox/Grid, transitions, keyframes).
- **`src/renderer/app.js`**: The main orchestrator. Handles file drop/select events, orchestrates loading states, layout toggles (Drop Zone vs Main Content), and registers global utilities (`showToast`, `formatDuration`).
- **`src/renderer/state/store.js`**: Centralized, mutable global state object (`state` and `window.appState`). Holds loaded file paths, audio info, markers array, metadata arrays, and excluded regions.
- **`src/renderer/modules/waveform.js`**: The most complex UI component. Wraps `wavesurfer.js` v7. Maps the global `state.markers` to WaveSurfer Regions. Handles zooming, spectrogram toggling, timeline rendering, and the advanced "Exclude Mode" (drag to mark red regions to skip during export).
- **`src/renderer/modules/tracklist.js`**: Reads markers from state and renders the list of tracks (Track 1, Track 2...). Attach event listeners for renaming, playing segments, and changing durations (which shifts subsequent markers).
- **`src/renderer/modules/controls.js`**: Wires up the parameter sliders (Threshold, Min Silence, Sensitivity), the "Auto Detect" button, and the "Export" button.
- **`src/renderer/modules/history.js`**: Simple Undo/Redo stack. Takes complete snapshots of `state` before destructive actions. Keyboard shortcuts: `Ctrl+Z`, `Ctrl+Y`.
- **`src/renderer/modules/smart-import.js`**: Parses raw pasted text (e.g., from Bandcamp or a CD rip log) into track times and titles. Calculates cumulative track times if only durations are provided.
- **`src/renderer/modules/discogs-ui.js`**: Manages the Discogs search modal, fetches tracklists, matches them to current audio segments based on duration tolerances, and applies metadata to state.

---

## 2. Core Data Flow & State Management

### The Global State (`state/store.js`)
```javascript
{
    filePath: null,         // Absolute path to the original audio file
    wavPath: null,          // Path to the decoded WAV file (for faster processing)
    audioInfo: null,        // { duration, sampleRate, ... }
    markers: [],            // Array of floats (seconds) denoting track start boundaries
    trackNames: [],         // Array of strings mapping to markers
    trackArtists: [],       // Array of strings mapping to markers
    excludedRegions: [],    // Array of {start, end} objects for audio data to skip
    isPlaying: false
}
```

### Gap Detection Flow
1. User clicks **"Auto Detect"**.
2. Frontend sends detection params (Threshold, Min Silence) via IPC to `AudioService.js`.
3. `AudioService.js` invokes `ffprobe` to scan volume levels, passing data lines back.
4. It calculates continuous segments where volume is below threshold for longer than Min Silence.
5. Returns an array of timestamps.
6. Frontend replaces `state.markers` with these timestamps.
7. `syncMarkersToRegions()` is called to draw vertical lines on the waveform.
8. `updateTracklist(state)` is called to re-render the track table below the waveform.

### Export Flow
1. User clicks **"Export Tracks"**.
2. Frontend scrapes DOM inputs for overall Album/Artist/Year, and reads per-track Names/Artists.
3. IPC payload is sent to `ExportService.js` containing `state.markers` and `state.excludedRegions`.
4. `ExportService.js` loops through markers to define `startTime` and `duration` for each track.
5. If `excludedRegions` fall within a track's boundaries, an FFmpeg `aselect` filter is dynamically built to omit those specific byte ranges.
6. Files are written to disk, ID3/Vorbis tags are injected.
7. Frontend displays a CSS animated Toast Notification upon success.

---

## 3. UI/UX Interaction Patterns

### Waveform Logic (`waveform.js`)
- **Seek**: Click track row in tracklist.
- **Markers**: Created via Auto Detect, Double-Clicking the waveform, or pressing `M` at the playhead.
- **Excluded Regions**: 
  - Toggled via `E` key (Exclude Mode). Cursor turns to crosshair, waveform gets a red dashed border.
  - Dragging creates red regions (`id: excluded_timestamp`). 
  - Overlapping regions automatically merge.
  - Double-clicking an excluded region prompts for deletion.
- **Zooming**: Slider UI, `+`/`-` buttons, "Fit" button, or `Ctrl + Mouse Wheel`.
- **Shortcuts**: `Space` (Play/Pause), `Arrow L/R` (Skip 5s), `Home/End` (Seek boundaries), `Delete` (Removes marker closest to playhead).

### Tracklist Logic (`tracklist.js`)
- The number of tracks is always `markers.length + 1`.
- Track 1 always starts at `0.0`. Track N always ends at `audio.duration`.
- Editing a track's duration changes the *end time* of that track, which physically shifts the marker, thus pushing/pulling all subsequent markers automatically.

---

## 4. Development & Build Setup
- **Development**: Run `npm run dev`. This launches Electron and watches for file changes.
- **Production Build**: Run `npm run build`. Uses `electron-builder` to package the app into a standalone Windows installer (`.exe`) in the `dist/` folder.
- **Dependencies**: 
  - `wavesurfer.js` v7 (loaded locally from `src/renderer/lib/` to bypass module loader issues).
  - `fluent-ffmpeg`, `ffmpeg-static`, `ffprobe-static` (bundled into the binary).
  - `node-id3` (for MP3 metadata injection).

---

## 5. Notes for AI Agents
- **Avoid Global Re-renders:** When modifying the DOM, prefer targeted updates over `.innerHTML` wipeouts to preserve event listeners and focus states.
- **File Paths:** Pay close attention to `ffmpeg.js`. Because `electron-builder` packs `node_modules` into a read-only `app.asar` archive, FFmpeg binaries must be `asarUnpack`ed (configured in `package.json`), and the paths dynamically rewritten to point to `app.asar.unpacked`.
- **WaveSurfer v7 Constraints:** We opted NOT to use the `MinimapPlugin` as the API for v7 had breaking changes that conflicted with our Regions setup.
- **Git Flow:** The user (Angki) prefers iterative, concise commits pushed sequentially to GitHub directly to the `main` branch.
